---
title: "Árvore de Decisão - Modelo de Machine Learning"
author: Laura Mº de Souza Romano
linkedin: https://www.linkedin.com/in/laura-maria-de-souza-romano/
database: https://archive.ics.uci.edu/dataset/222/bank+marketing 
---

``` {R Descrição do projeto}

Os dados estão relacionados com campanhas de marketing direto de uma instituição bancária portuguesa. Essas campanhas de marketing foram baseadas em telefonemas e, em muitos casos, era necessário mais do que um contacto para o mesmo cliente, para saber se 
o produto (depósito bancário a prazo) seria ("sim") ou não ("não") adquirido.

Para isso, usaremos um modelo de árvore de decisão que nos permitirá tomar decisões lógicas e segmentar os clientes em grupos com maior probabilidade de adquirir o produto ("sim") ou não ("não"). As árvores de decisão são algoritmos de aprendizado de máquina que dividem o conjunto de dados em subgrupos com base nas características dos clientes, de modo que cada subgrupo seja o mais puro possível em relação à variável de destino, neste caso, a decisão de adquirir ou não o depósito bancário a prazo.

O processo de construção da árvore de decisão envolve a seleção de variáveis independentes (como idade, ocupação, estado civil, etc.) que podem ser relevantes para prever a resposta desejada. A árvore de decisão divide os dados em ramos, onde cada ramo representa uma escolha entre diferentes valores de uma variável independente. Cada folha da árvore representa uma decisão final, que neste caso seria a previsão da resposta do cliente à campanha de marketing.


```

``` {R Sumário de variáveis}

1 - age: idade (numérica)

2 - job: tipo de trabalho
(categórica: 'admin.','blue-collar','entrepreneur','housemaid',
'management','retired','self-employed','services','student','technician','unemployed','unknown')

3 - marital: estado civíl
(categórica: 'divorced','married','single','unknown'; 
note: 'divorced' means divorced or widowed)

4 - education: nível educacional
(categórica: 'basic.4y','basic.6y','basic.9y','high.school','illiterate',
'professional.course','university.degree','unknown')

5 - default: tem crédito em inadimplência?
(categórica: 'no','yes','unknown')

6 - housing: tem crédito habitação?
(categórica: 'no','yes','unknown')

7 - loan: tem empréstimo pessoal? 
(categórica: 'no','yes','unknown') 

8 - contact: tipo de comunicação de contato 
(categórica: 'cellular','telephone') 

9 - month: mês do ano de último contato
(categórica: 'jan', 'feb', 'mar', ..., 'nov', 'dec')

10 - day_of_week: dia da semana de último contato
(categórica: 'mon','tue','wed','thu','fri')


11 - duration: duração do último contato, em segundo (numérico). 
Observação importante: esse atributo afeta muito o destino de saída (por exemplo, se duração=0, então y='não'). No entanto, a duração não é conhecida antes de uma chamada ser realizada. Além disso, após o final da chamada, y é obviamente conhecido. Assim, esta entrada deve ser incluída apenas para fins de benchmark e deve ser descartada se a intenção seja ter um modelo preditivo realista.


12 - campaign: número de contactos realizados nesta campanha e para este cliente 
(numérico, inclue último contato)

13 - pdays: dias que se passaram desde que o cliente foi contatado pela última vez em uma campanha anterior 
(numérico, 999 significa que o cliente não teve contato prévio)

14 - previous: número de contactos realizados antes desta campanha e para este cliente (numérico)

15 - poutcome: resultado da campanha de marketing anterior 
(categórico: 'failure','nonexistent','success')   

16 - emp.var.rate: taxa de variação do emprego - indicador trimestral (numérico)
17 - cons.price.idx: índice de preços ao consumidor - indicador mensal (numérico)   
18 - cons.conf.idx: índice de confiança do consumidor - indicador mensal (numérico)    
19 - euribor3m: taxa euribor (indica a taxa de juros média dos empréstimos interbancários sem garantia da Zona Euro) a 3 meses - indicador diário (numérico)
20 - nr.employed: número de funcionários - indicador trimestral (numérico)

```


```{r Bibliotecas utilizadas}

library(readr)
library(rsample)
library(ggplot2)
library(dplyr)
library(caret)
library(Amelia)
library(pROC)
library(rpart)
library(rpart.plot)
library(ggplot2)
```

```{r Leitura da base}

base <-read.csv2("bank-additional-full.csv")
# View(base)

```

- Análise Exploratória e levantamentos estatísticos:

```{r Análise das variáveis}

str(base)

```

```{r Ajuste Categorias}

base$job <- as.factor(base$job)
base$marital <- as.factor(base$marital)
base$education <- as.factor(base$education)
base$default <- as.factor(base$default)
base$housing <- as.factor(base$housing)
base$contact <- as.factor(base$contact)
base$poutcome <- as.factor(base$poutcome)
base$loan <- as.factor(base$loan)
base$y <- as.factor(base$y)

base$emp.var.rate <- as.numeric(base$emp.var.rate)
base$cons.price.idx <- as.numeric(base$cons.price.idx)
base$cons.conf.idx <- as.numeric(base$cons.conf.idx)
base$euribor3m <- as.numeric(base$euribor3m)
base$nr.employed  <- as.numeric(base$nr.employed)



base$month <- factor(base$month, levels = c("jan", "feb", "mar", "apr", "may", "jun",
                                            "jul", "aug", "sep", "oct", "nov", "dec"),
                     labels = c("Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
                                "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"))

base$day_of_week <- factor(base$day_of_week, levels = c("mon", "tue", "wed", "thu", "fri", "sat", "sun"),
                           labels = c("Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado", "Domingo"))

# str(base)

```


``` {R Correlação}

colunas_numericas <- base %>%
  select_if(is.numeric)

matriz_correlacao <- cor(colunas_numericas)

matriz_correlacao_df <- as.data.frame(as.table(matriz_correlacao))

ggplot(matriz_correlacao_df, aes(x = Var1, y = Var2, fill = Freq)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "lightblue") +
  labs(title = "Matriz de Correlação") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
``` {R Dados Estatísticos}

t(summary(colunas_numericas)) #infos estatísticas da variáveis numéricas

```
``` {R Histogramas}

nome_colunas <- colnames(colunas_numericas) # nome colunas

par(mfrow = c(2, 5)) #subplot

for (i in nome_colunas) {
  hist(base[[i]], main = paste(i), xlab = i)
}

```


```{r Treino e Teste}

set.seed(123)
divisao <- initial_split(base, prop = 0.7)
treino <- training(divisao)
teste <- testing(divisao)

```

```{r Validação Cruzada e Modelo}

# Definindo os parâmetros de controle do treinamento:

# - O resultado do controle é armazenado na variável ctrl

ctrl <- trainControl(method = "cv", # validação cruzada
                     number = 10, # folds
                     summaryFunction = twoClassSummary, # função de resumo para problemas de classif binária
                     classProbs = TRUE) # ermitir a saída das probabilidades das classes.

# Modelo treinado:

# - O resultado do treinamento (modelo ajustado) é armazenado na variável dtFit.

dtFit <- train(y ~ ., #target em relação a todos os outros parâmetros
               method = "rpart2", # usa a profundidade máxima (caso rpart, o parâmetro seria o de complexidade)
               tuneLength = 5,  # até 20 valores por nós
               trControl = ctrl, # objeto ctrl estabelecido com a validação cruzada
               metric = 'ROC', # métrica de avaliação: curva ROC
               data = treino) # utilizando o conjunto de treinamento

dtFit
# plot(dtFit)

```

``` {R Árvore de Decisão}

rpart.plot(dtFit$finalModel,
           extra = 4, # informação extra nos nós
           type = 1, # tipo de gráfico
           box.palette = "RdYlGn") # cor dos nós

```


Predições:


``` {R Predições com o modelo treinado}

preddt <- predict(dtFit, teste, type = "prob") # utilizando o modelo dtFit, com a base de teste, com resultados atraves das probabilidades

resultdt <- as.factor(ifelse(preddt[,2] > 0.5, "yes", "no")) # preddt[,2] - coluna com as prob de 'yes

```

Desempenho do Modelo:

``` {R Matriz de Confusão}

# library(carret)

confusionMatrix(resultdt, teste$y, positive = "yes")

```

``` {R Curva ROC AUC}

# library(pROC)

aucdf <- roc(teste$y, preddt[,2])
plot.roc(aucdf, print.thres = T) # descobrimos o melhor ponto de corte

```

``` {R Predições com o modelo treinado em novo ponto de corte}

preddt <- predict(dtFit, teste, type = "prob") # utilizando o modelo dtFit, com a base de teste, com resultados atraves das probabilidades

resultdt <- as.factor(ifelse(preddt[,2] > 0.089, "yes", "no")) # preddt[,2] - coluna com as prob de 'yes

confusionMatrix(resultdt, teste$y, positive = "yes")

```





