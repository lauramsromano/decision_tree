---
title: "Árvore de Decisão - Modelo de Machine Learning"
author: Laura Mº de Souza Romano
linkedin: https://www.linkedin.com/in/laura-maria-de-souza-romano/
database: https://archive.ics.uci.edu/dataset/222/bank+marketing 
---

``` {R Descrição do projeto}

Os dados estão relacionados com campanhas de marketing direto de uma instituição bancária portuguesa. Essas campanhas de marketing foram baseadas em telefonemas e, em muitos casos, era necessário mais do que um contacto para o mesmo cliente, para saber se o produto (depósito bancário a prazo) seria ("sim") ou não ("não") adquirido.

Para isso, usaremos um modelo de árvore de decisão que nos permitirá tomar decisões lógicas e segmentar os clientes em grupos com maior probabilidade de adquirir o produto ("sim") ou não ("não"). As árvores de decisão são algoritmos de aprendizado de máquina que dividem o conjunto de dados em subgrupos com base nas características dos clientes, de modo que cada subgrupo seja o mais puro possível em relação à variável de destino, neste caso, a decisão de adquirir ou não o depósito bancário a prazo.

O processo de construção da árvore de decisão envolve a seleção de variáveis independentes (como idade, ocupação, estado civil, etc.) que podem ser relevantes para prever a resposta desejada. A árvore de decisão divide os dados em ramos, onde cada ramo representa uma escolha entre diferentes valores de uma variável independente. Cada folha da árvore representa uma decisão final, que neste caso seria a previsão da resposta do cliente à campanha de marketing.


```

``` {R Sumário de variáveis}

1 - age: idade (numérica)

2 - job: tipo de trabalho
(categórica: 'admin.','blue-collar','entrepreneur','housemaid',
'management','retired','self-employed','services','student','technician','unemployed','unknown')

3 - marital: estado civíl
(categórica: 'divorced','married','single','unknown'; 
note: 'divorced' means divorced or widowed)

4 - education: nível educacional
(categórica: 'basic.4y','basic.6y','basic.9y','high.school','illiterate',
'professional.course','university.degree','unknown')

5 - default: tem crédito em inadimplência?
(categórica: 'no','yes','unknown')

6 - housing: tem crédito habitação?
(categórica: 'no','yes','unknown')

7 - loan: tem empréstimo pessoal? 
(categórica: 'no','yes','unknown') 

8 - contact: tipo de comunicação de contato 
(categórica: 'cellular','telephone') 

9 - month: mês do ano de último contato
(categórica: 'jan', 'feb', 'mar', ..., 'nov', 'dec')

10 - day_of_week: dia da semana de último contato
(categórica: 'mon','tue','wed','thu','fri')

11 - duration: duração do último contato, em segundo (numérico). 
Observação importante: esse atributo afeta muito o destino de saída (por exemplo, se duração=0, então y='não'). No entanto, a duração não é conhecida antes de uma chamada ser realizada. Além disso, após o final da chamada, y é obviamente conhecido. Assim, esta entrada deve ser incluída apenas para fins de benchmark e deve ser descartada se a intenção seja ter um modelo preditivo realista.

12 - campaign: número de contactos realizados nesta campanha e para este cliente 
(numérico, inclue último contato)

13 - pdays: dias que se passaram desde que o cliente foi contatado pela última vez em uma campanha anterior 
(numérico, 999 significa que o cliente não teve contato prévio)

14 - previous: número de contactos realizados antes desta campanha e para este cliente (numérico)

15 - poutcome: resultado da campanha de marketing anterior 
(categórico: 'failure','nonexistent','success')   

16 - emp.var.rate: taxa de variação do emprego - indicador trimestral (numérico)
17 - cons.price.idx: índice de preços ao consumidor - indicador mensal (numérico)   
18 - cons.conf.idx: índice de confiança do consumidor - indicador mensal (numérico)    
19 - euribor3m: taxa euribor (indica a taxa de juros média dos empréstimos interbancários sem garantia da Zona Euro) a 3 meses - indicador diário (numérico)
20 - nr.employed: número de funcionários - indicador trimestral (numérico)
21 - y: target, diz se o cliente aderiu ou não o produto 
(categórica: 'no','yes')

```

```{R Bibliotecas utilizadas}

library(readr)
library(rsample)
library(ggplot2)
library(dplyr)
library(caret)
library(Amelia)
library(pROC)
library(rpart)
library(rpart.plot)
library(ggplot2)
library(tidyr)
```

```{r Leitura da base}

base <- read.csv2("bank-additional-full.csv")
# View(base)

```

```{r Análise das variáveis}

str(base)

```

``` {R Ajuste na base}

# Colunas temporais:

base$month <- factor(base$month, levels = c("jan", "feb", "mar", "apr", "may", "jun",
                                            "jul", "aug", "sep", "oct", "nov", "dec"),
                     labels = c("Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
                                "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"))

base$day_of_week <- factor(base$day_of_week, levels = c("mon", "tue", "wed", "thu", "fri", "sat", "sun"),
                           labels = c("Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado", "Domingo"))

# Colunas categóricas:

base$job <- as.factor(base$job)
base$marital <- as.factor(base$marital)
base$education <- as.factor(base$education)
base$default <- as.factor(base$default)
base$housing <- as.factor(base$housing)
base$contact <- as.factor(base$contact)
base$poutcome <- as.factor(base$poutcome)
base$loan <- as.factor(base$loan)
base$y <- as.factor(base$y)

# Colunas numéricas:

base$emp.var.rate <- as.numeric(base$emp.var.rate)
base$cons.price.idx <- as.numeric(base$cons.price.idx)
base$cons.conf.idx <- as.numeric(base$cons.conf.idx)
base$euribor3m <- as.numeric(base$euribor3m)
base$nr.employed  <- as.numeric(base$nr.employed)


```

``` {R Verificação valores nulos}

missing_proportions <- sapply(base, function(x) sum(is.na(x)))
print(missing_proportions)


# Identifique variáveis com valores ausentes e avalie 
# a proporção de valores faltantes em cada variável.

```

############### Análise Exploratória e levantamentos estatísticos:

######## Variáveis Numéricas:

``` {R Dados Estatísticos - Variáveis numéricas}

colunas_numericas <- base %>% 
  select_if(is.numeric)
nome_colunas_num <- colnames(colunas_numericas) 


t(summary(colunas_numericas))

```

``` {R Análise de Correlação - Variáveis numéricas}

target <- ifelse(base$y == "yes", 1, 0) 

correlations <- sapply(colunas_numericas, function(var) cor(var, target)) 
correlation_df <- data.frame(Correlação = correlations) 
correlation_df

# Calcule medidas de correlação (por exemplo, coeficiente de correlação de Pearson) 
# entre variáveis numéricas e a target.

```

``` {R Distribuição - Variáveis numéricas}

par(mfrow = c(2, 5)) # subplot

for (i in nome_colunas_num) {
  hist(base[[i]], main = paste(i), xlab = i, col = "#1f78b4")
}

# Use gráficos de dispersão ou box plots para visualizar 
# a relação entre variáveis numéricas e a variável de destino.

```

``` {R Boxplot das variáveis numéricas}

for (i in nome_colunas_num) {
  p <- ggplot(base, aes(x = y, y = !!sym(i), fill = y)) +
    geom_boxplot() +
    labs(title = paste("Box Plot de Target em relação à", i),
         x = "Variável Y", 
         y = i,
         fill = "Variável Y") +
    theme_minimal() +
    scale_fill_manual(values = c("#1f78b4", "#a6cee3"))

  print(p)
}


# Use gráficos de dispersão ou box plots para visualizar 
# a relação entre variáveis numéricas e a variável de destino.

```

######## Variáveis Categóricas:

``` {R Análise de Correlação - Variáveis categóricas}

colunas_categoricas <- base %>%
  select_if(is.factor)

nome_colunas_cat <- colnames(colunas_categoricas)
nome_colunas_cat <- nome_colunas_cat[nome_colunas_cat != 'y'] # removendo a coluna 'y' (target)
nome_colunas_cat <- nome_colunas_cat[nome_colunas_cat != 'month'] # removendo a coluna 'month' (target)
nome_colunas_cat <- nome_colunas_cat[nome_colunas_cat != 'day_of_week'] # removendo a coluna 'day_of_week' (target)

resultados <- data.frame(Categoria = character(0), PValor = numeric(0))

for (i in nome_colunas_cat) {
  contingency_table <- table(base[[i]], base$y)
  chi_squared <- chisq.test(contingency_table)
  validacao <- ifelse(chi_squared$p.value < 0.05, 'Há correlação', 'Não há correlação')
  
  novo_registro <- data.frame(Categoria = i, PValor = chi_squared$p.value, Correlação = validacao)

  resultados <- rbind(resultados, novo_registro)
}

resultados

```

``` {R Percentual por resposta em cada categoria - Variáveis categóricas}

for (i in nome_colunas_cat) {
  a <- base %>%
    group_by(!!sym(i), y) %>%
    summarise(n = n(), .groups = 'drop') %>%
    mutate(Perc = (n / sum(n)) * 100)
    
  p <- ggplot(a, aes(x = !!sym(i), y = Perc, fill = y)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(aes(label = paste0(round(Perc, 1), "%")), 
              position = position_dodge(width = 0.9), vjust = -0.5) +
    labs(title = paste("Distribuição das categorias em", i, "por resposta"),
         x = i,
         y = "Percentual",
         fill = "target") +
    coord_cartesian(ylim = c(0, max(a$Perc) + 5)) +
    theme_minimal() +
    theme(legend.position = "top",
          axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("#1f78b4", "#a6cee3"))

  print(p)
}


# Crie tabelas de contingência e gráficos de barras para entender a 
# distribuição das categorias em variáveis categóricas em relação à 
# variável de destino ("sim" ou "não" para adquirir o depósito bancário a prazo).


```

``` {R Taxa de Conversão - Variáveis categóricas}

for (i in nome_colunas_cat) {
  conversion_rates <- base %>%
    group_by(!!sym(i)) %>%
    summarise(conversion_rate = sum(y == "yes") / n())
  
  conversion_rates <- conversion_rates %>%
    arrange(desc(conversion_rate))
  
  print(conversion_rates)
}


# Calcule as taxas de conversão para cada categoria e avalie 
# a influência potencial de cada variável categórica na decisão. 

```
######## Target:

```{R Análise Temporal da 'target'}

nome_colunas_tempo <- c("month", "day_of_week")

for (i in nome_colunas_tempo) {
  
  a <- base %>% 
    group_by(!!sym(i), y) %>% 
    summarise(n = n(), .groups = 'drop')
  
  p <- ggplot(a, aes(x = !!sym(i), y = n, fill = y)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = paste("Histograma de Barras Agrupadas por", i),
         x = i, y = "Contagem",
         fill = "target") +
    scale_fill_manual(values = c("#1f78b4", "#a6cee3")) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p)
  
}

```
############### Modelo ML - Árvore de Decisão:

```{r Separação dados de Treino e Teste}

set.seed(123) 
divisao <- initial_split(base, prop = 0.7)
treino <- training(divisao)
teste <- testing(divisao)

```

```{r Validação Cruzada e Modelo}

# Definindo os parâmetros de controle do treinamento:

ctrl <- trainControl(method = "cv", # validação cruzada
                     number = 10, # quantidade de folds
                     summaryFunction = twoClassSummary, # função de resumo para problemas de classif binária
                     classProbs = TRUE) # permitir a saída das probabilidades das classes

# Modelo treinado:


dtFit <- train(y ~ ., # target em relação a todos os outros parâmetros
               method = "rpart2", # usa a profundidade máxima (caso rpart, o parâmetro seria o de complexidade)
               tuneLength = 5,  # até 20 valores por nós
               trControl = ctrl, # objeto ctrl estabelecido com a validação cruzada
               metric = 'ROC', # métrica de avaliação: curva ROC
               data = treino) # utilizando o conjunto de treinamento

dtFit
# plot(dtFit)

```

``` {R Visualização da Árvore de Decisão}

rpart.plot(dtFit$finalModel,
           extra = 4, # informação extra nos nós
           type = 1, # tipo de gráfico
           box.palette = "RdYlGn") # cor dos nós

```

######## Predições:

``` {R Predições com o modelo treinado}

preddt <- predict(dtFit, teste, type = "prob") # utilizando o modelo dtFit, com a base de teste, com resultados através das probabilidades
resultdt <- as.factor(ifelse(preddt[,2] > 0.5, "yes", "no")) # preddt[,2] - coluna com as prob de 'yes'
resultdt

```
######## Desempenho do Modelo:

``` {R Matriz de Confusão}

confusionMatrix(resultdt, teste$y, positive = "yes")

```

``` {R Curva ROC AUC}

aucdf <- roc(teste$y, preddt[,2])
plot.roc(aucdf, print.thres = T) #  print.thres: descobrimos o melhor ponto de corte

```

``` {R Predições com o modelo treinado em novo ponto de corte}

# preddt <- predict(dtFit, teste, type = "prob") 
# resultdt <- as.factor(ifelse(preddt[,2] > 0.089, "yes", "no")) 

# confusionMatrix(resultdt, teste$y, positive = "yes")

```





