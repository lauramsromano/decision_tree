---
title: "Árvore de Decisão - Modelo de Machine Learning"
author: Laura Mº de Souza Romano
linkedin: https://www.linkedin.com/in/laura-maria-de-souza-romano/
database: https://archive.ics.uci.edu/dataset/222/bank+marketing 
---

``` {R Descrição do projeto}

Os dados estão relacionados com campanhas de marketing direto de uma instituição bancária portuguesa. Essas campanhas de marketing foram baseadas em telefonemas e, em muitos casos, era necessário mais do que um contacto para o mesmo cliente, para saber se 
o produto (depósito bancário a prazo) seria ("sim") ou não ("não") adquirido.

Para isso, usaremos um modelo de árvore de decisão que nos permitirá tomar decisões lógicas e segmentar os clientes em grupos com maior probabilidade de adquirir o produto ("sim") ou não ("não"). As árvores de decisão são algoritmos de aprendizado de máquina que dividem o conjunto de dados em subgrupos com base nas características dos clientes, de modo que cada subgrupo seja o mais puro possível em relação à variável de destino, neste caso, a decisão de adquirir ou não o depósito bancário a prazo.

O processo de construção da árvore de decisão envolve a seleção de variáveis independentes (como idade, ocupação, estado civil, etc.) que podem ser relevantes para prever a resposta desejada. A árvore de decisão divide os dados em ramos, onde cada ramo representa uma escolha entre diferentes valores de uma variável independente. Cada folha da árvore representa uma decisão final, que neste caso seria a previsão da resposta do cliente à campanha de marketing.


```

``` {R Sumário de variáveis}

1 - age: idade (numérica)

2 - job: tipo de trabalho
(categórica: 'admin.','blue-collar','entrepreneur','housemaid',
'management','retired','self-employed','services','student','technician','unemployed','unknown')

3 - marital: estado civíl
(categórica: 'divorced','married','single','unknown'; 
note: 'divorced' means divorced or widowed)

4 - education: nível educacional
(categórica: 'basic.4y','basic.6y','basic.9y','high.school','illiterate',
'professional.course','university.degree','unknown')

5 - default: tem crédito em inadimplência?
(categórica: 'no','yes','unknown')

6 - housing: tem crédito habitação?
(categórica: 'no','yes','unknown')

7 - loan: tem empréstimo pessoal? 
(categórica: 'no','yes','unknown') 

8 - contact: tipo de comunicação de contato 
(categórica: 'cellular','telephone') 

9 - month: mês do ano de último contato
(categórica: 'jan', 'feb', 'mar', ..., 'nov', 'dec')

10 - day_of_week: dia da semana de último contato
(categórica: 'mon','tue','wed','thu','fri')

11 - duration: duração do último contato, em segundo (numérico). 
Observação importante: esse atributo afeta muito o destino de saída (por exemplo, se duração=0, então y='não'). No entanto, a duração não é conhecida antes de uma chamada ser realizada. Além disso, após o final da chamada, y é obviamente conhecido. Assim, esta entrada deve ser incluída apenas para fins de benchmark e deve ser descartada se a intenção seja ter um modelo preditivo realista.

12 - campaign: número de contactos realizados nesta campanha e para este cliente 
(numérico, inclue último contato)

13 - pdays: dias que se passaram desde que o cliente foi contatado pela última vez em uma campanha anterior 
(numérico, 999 significa que o cliente não teve contato prévio)

14 - previous: número de contactos realizados antes desta campanha e para este cliente (numérico)

15 - poutcome: resultado da campanha de marketing anterior 
(categórico: 'failure','nonexistent','success')   

16 - emp.var.rate: taxa de variação do emprego - indicador trimestral (numérico)
17 - cons.price.idx: índice de preços ao consumidor - indicador mensal (numérico)   
18 - cons.conf.idx: índice de confiança do consumidor - indicador mensal (numérico)    
19 - euribor3m: taxa euribor (indica a taxa de juros média dos empréstimos interbancários sem garantia da Zona Euro) a 3 meses - indicador diário (numérico)
20 - nr.employed: número de funcionários - indicador trimestral (numérico)
21 - y: target, diz se o cliente aderiu ou não o produto 
(categórica: 'no','yes')

```


```{r Bibliotecas utilizadas}

library(readr)
library(rsample)
library(ggplot2)
library(dplyr)
library(caret)
library(Amelia)
library(pROC)
library(rpart)
library(rpart.plot)
library(ggplot2)
library(tidyr)
```

```{r Leitura da base}

base <-read.csv2("bank-additional-full.csv")
# View(base)

```

- Análise Exploratória e levantamentos estatísticos:

```{r Análise das variáveis}

str(base)

```

```{r Ajuste Categorias e Valores Numéricos}

base$job <- as.factor(base$job)
base$marital <- as.factor(base$marital)
base$education <- as.factor(base$education)
base$default <- as.factor(base$default)
base$housing <- as.factor(base$housing)
base$contact <- as.factor(base$contact)
base$poutcome <- as.factor(base$poutcome)
base$loan <- as.factor(base$loan)
base$y <- as.factor(base$y)

base$emp.var.rate <- as.numeric(base$emp.var.rate)
base$cons.price.idx <- as.numeric(base$cons.price.idx)
base$cons.conf.idx <- as.numeric(base$cons.conf.idx)
base$euribor3m <- as.numeric(base$euribor3m)
base$nr.employed  <- as.numeric(base$nr.employed)


base$month <- factor(base$month, levels = c("jan", "feb", "mar", "apr", "may", "jun",
                                            "jul", "aug", "sep", "oct", "nov", "dec"),
                     labels = c("Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
                                "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"))

base$day_of_week <- factor(base$day_of_week, levels = c("mon", "tue", "wed", "thu", "fri", "sat", "sun"),
                           labels = c("Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado", "Domingo"))

# str(base)

```


``` {R Dados Estatísticos}

t(summary(colunas_numericas)) # infos estatísticas da variáveis numéricas

```

``` {R Correlação}


colunas_numericas <- base %>% # variáveis numéricas
  select_if(is.numeric)

target <- ifelse(base$y == "yes", 1, 0) # target como variável numérica

correlations <- sapply(colunas_numericas, function(var) cor(var, target)) # cálculo correlação
correlation_df <- data.frame(Correlação = correlations) 

correlation_df

```

``` {R Histogramas}

nome_colunas <- colnames(colunas_numericas) # nome colunas numéricas

par(mfrow = c(2, 5)) # subplot

for (i in nome_colunas) {
  hist(base[[i]], main = paste(i), xlab = i)
}

```

```{R Análise Temporal da target}

agrup_mes <- base %>% 
  group_by(month, y) %>% 
  summarise(n = n(), .groups = 'drop')  # definir o argumento .groups como 'drop' para remover o agrupamento

agrup_day <- base %>% 
  group_by(day_of_week, y) %>% 
  summarise(n = n(), .groups = 'drop')

plot_mes <- ggplot(agrup_mes, aes(x = month, y = n, fill = y)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Histograma de Barras Agrupadas por Mês",
       x = "Mês", y = "Contagem",
       fill = "Variável Y")

plot_day <- ggplot(agrup_day, aes(x = day_of_week, y = n, fill = y)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Histograma de Barras Agrupadas por Mês",
       x = "Mês", y = "Contagem",
       fill = "Variável Y")


print(plot_mes)
print(plot_day)

```


```{r Separação dados de Treino e Teste}

set.seed(123) 
divisao <- initial_split(base, prop = 0.7)
treino <- training(divisao)
teste <- testing(divisao)

```

```{r Validação Cruzada e Modelo}

# Definindo os parâmetros de controle do treinamento:

ctrl <- trainControl(method = "cv", # validação cruzada
                     number = 10, # quantidade de folds
                     summaryFunction = twoClassSummary, # função de resumo para problemas de classif binária
                     classProbs = TRUE) # permitir a saída das probabilidades das classes

# Modelo treinado:


dtFit <- train(y ~ ., # target em relação a todos os outros parâmetros
               method = "rpart2", # usa a profundidade máxima (caso rpart, o parâmetro seria o de complexidade)
               tuneLength = 5,  # até 20 valores por nós
               trControl = ctrl, # objeto ctrl estabelecido com a validação cruzada
               metric = 'ROC', # métrica de avaliação: curva ROC
               data = treino) # utilizando o conjunto de treinamento

dtFit
# plot(dtFit)

```

``` {R Visualização da Árvore de Decisão}

rpart.plot(dtFit$finalModel,
           extra = 4, # informação extra nos nós
           type = 1, # tipo de gráfico
           box.palette = "RdYlGn") # cor dos nós

```

- Predições:


``` {R Predições com o modelo treinado}

preddt <- predict(dtFit, teste, type = "prob") # utilizando o modelo dtFit, com a base de teste, com resultados atraves das probabilidades
resultdt <- as.factor(ifelse(preddt[,2] > 0.5, "yes", "no")) # preddt[,2] - coluna com as prob de 'yes'
resultdt

```

- Desempenho do Modelo:

``` {R Matriz de Confusão}

confusionMatrix(resultdt, teste$y, positive = "yes")

```

``` {R Curva ROC AUC}

aucdf <- roc(teste$y, preddt[,2])
plot.roc(aucdf, print.thres = T) #  print.thres: descobrimos o melhor ponto de corte

```

``` {R Predições com o modelo treinado em novo ponto de corte}

preddt <- predict(dtFit, teste, type = "prob") 
resultdt <- as.factor(ifelse(preddt[,2] > 0.089, "yes", "no")) 

confusionMatrix(resultdt, teste$y, positive = "yes")

```





